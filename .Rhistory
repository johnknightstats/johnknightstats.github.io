# ----------------------------
con <- dbConnect(RSQLite::SQLite(), path.expand(DB_PATH))
on.exit(dbDisconnect(con), add = TRUE)
sql <- "
SELECT
m.season,
m.match_id,
m.match_date,
th.team_name AS home_team,
ta.team_name AS away_team,
tmh.goals     AS home_goals,
tma.goals     AS away_goals
FROM Match m
JOIN Team th
ON th.team_id = m.home_team_id
JOIN Team ta
ON ta.team_id = m.away_team_id
JOIN Team_Match tmh
ON tmh.match_id = m.match_id AND tmh.team_id = m.home_team_id
JOIN Team_Match tma
ON tma.match_id = m.match_id AND tma.team_id = m.away_team_id
WHERE m.competition_id = ?
ORDER BY m.match_date, m.match_id
"
clean_team_name <- function(x) {
x <- gsub("^(AFC|FC)\\s+", "", x, perl = TRUE)
x <- gsub("\\s+(AFC|FC)$", "", x, perl = TRUE)
trimws(x)
}
df <- dbGetQuery(con, sql, params = list(COMP_ID)) |>
mutate(
match_date = as.Date(match_date),
home_goals = as.integer(home_goals),
away_goals = as.integer(away_goals),
home_team  = clean_team_name(home_team),
away_team  = clean_team_name(away_team)
)
if (nrow(df) == 0) stop("Query returned 0 rows. Check DB_PATH / schema / competition_id.")
write_csv(df, OUT_CSV)
message("Wrote ", nrow(df), " rows to ", OUT_CSV)
shiny::runApp('shiny/league-table')
#!/usr/bin/env Rscript
# build_results_cache.R
# ------------------------------------------------------------
# Reads:  SQLite
#   - Historical: Match + Team_Match + Team  (competition_id = 9)
#   - 2025/2026+: Fotmob_Match (league_derived = "Premier League")
# Writes: results_cache_comp9.csv
#
# Output columns:
# season, match_id, match_date, home_team, away_team, home_goals, away_goals
# ------------------------------------------------------------
suppressPackageStartupMessages({
library(DBI)
library(RSQLite)
library(dplyr)
library(readr)
library(lubridate)
})
# ----------------------------
# Config
# ----------------------------
DB_PATH   <- Sys.getenv("FOOTBALLDB1_SQLITE", unset = "~/Data/footballdb1.sqlite")
SITE_ROOT <- "~/Projects/johnknightstats.github.io"
APP_DIR   <- file.path(SITE_ROOT, "shiny", "league-table")
dir.create(APP_DIR, recursive = TRUE, showWarnings = FALSE)
OUT_CSV   <- file.path(APP_DIR, "results_cache_comp9.csv")
COMP_ID   <- 9
FOTMOB_LEAGUE <- "Premier League"
FOTMOB_MIN_SEASON_ENDYEAR <- 2026  # 2025/2026 season and later
# ----------------------------
# Helpers
# ----------------------------
clean_team_name <- function(x) {
x <- gsub("^(AFC|FC)\\s+", "", x, perl = TRUE)
x <- gsub("\\s+(AFC|FC)$", "", x, perl = TRUE)
trimws(x)
}
season_end_year <- function(season) {
# handles both "1990-1991" and "2025/2026"
y <- suppressWarnings(as.integer(substr(season, 6, 9)))
y
}
# ----------------------------
# Build cache
# ----------------------------
con <- dbConnect(RSQLite::SQLite(), path.expand(DB_PATH))
on.exit(dbDisconnect(con), add = TRUE)
# ---- Historical (up to 2024/2025, and anything pre-2025/2026) from Match/Team_Match/Team
sql_hist <- '
SELECT
m.season,
m.match_id,
m.match_date,
th.team_name AS home_team,
ta.team_name AS away_team,
tmh.goals     AS home_goals,
tma.goals     AS away_goals
FROM "Match" m
JOIN "Team" th
ON th.team_id = m.home_team_id
JOIN "Team" ta
ON ta.team_id = m.away_team_id
JOIN "Team_Match" tmh
ON tmh.match_id = m.match_id AND tmh.team_id = m.home_team_id
JOIN "Team_Match" tma
ON tma.match_id = m.match_id AND tma.team_id = m.away_team_id
WHERE m.competition_id = ?
ORDER BY m.match_date, m.match_id
'
hist <- dbGetQuery(con, sql_hist, params = list(COMP_ID)) |>
mutate(
match_date = as.Date(match_date),
home_goals = as.integer(home_goals),
away_goals = as.integer(away_goals),
home_team  = clean_team_name(home_team),
away_team  = clean_team_name(away_team),
season_end = season_end_year(season)
) |>
filter(!is.na(season_end), season_end < FOTMOB_MIN_SEASON_ENDYEAR) |>
select(season, match_id, match_date, home_team, away_team, home_goals, away_goals)
# ---- 2025/2026+ from Fotmob_Match
# match_time_utc example: 2025-08-31T15:30:00:000Z
# We'll parse to Date in R after pulling as text.
sql_fotmob <- '
SELECT
fm.season_derived AS season,
fm.match_id       AS match_id,
fm.match_time_utc AS match_time_utc,
fm.home_team_name AS home_team,
fm.away_team_name AS away_team,
fm.home_score     AS home_goals,
fm.away_score     AS away_goals
FROM "Fotmob_Match" fm
WHERE fm.league_derived = ?
ORDER BY fm.match_time_utc, fm.match_id
'
fotmob_raw <- dbGetQuery(con, sql_fotmob, params = list(FOTMOB_LEAGUE)) |>
mutate(
season = as.character(season),
season_end = season_end_year(season)
) |>
filter(!is.na(season_end), season_end >= FOTMOB_MIN_SEASON_ENDYEAR)
# Parse match_time_utc -> match_date
# Handle both "...:000Z" and standard ISO "...Z"
fotmob <- fotmob_raw |>
mutate(
match_date = suppressWarnings(as.Date(ymd_hms(match_time_utc, tz = "UTC"))),
match_date = ifelse(
is.na(match_date),
as.Date(parse_date_time(match_time_utc, orders = c("Ymd HMS", "Ymd HMS:OS", "YmdTHMS", "YmdTHMS:OS"), tz = "UTC")),
match_date
),
match_date = as.Date(match_date, origin = "1970-01-01"),
home_goals = as.integer(home_goals),
away_goals = as.integer(away_goals),
home_team  = clean_team_name(home_team),
away_team  = clean_team_name(away_team)
) |>
# Keep only matches with a parsable date; scores can be NA for future fixtures (that's fine)
filter(!is.na(match_date)) |>
select(season, match_id, match_date, home_team, away_team, home_goals, away_goals)
# ---- Combine and write
df <- bind_rows(hist, fotmob) |>
arrange(match_date, match_id)
if (nrow(df) == 0) stop("Combined query returned 0 rows. Check DB_PATH/schema/filters.")
write_csv(df, OUT_CSV)
message("Wrote ", nrow(df), " rows to ", OUT_CSV)
message(" - Historical rows: ", nrow(hist))
message(" - Fotmob rows:     ", nrow(fotmob))
runApp('shiny/league-table')
runApp('shiny/league-table')
runApp('shiny/league-table')
runApp('shiny/league-table')
#!/usr/bin/env Rscript
# build_results_cache.R
# ------------------------------------------------------------
# Reads:  SQLite
#   - Historical: Match + Team_Match + Team  (competition_id = 9)
#   - 2025/2026+: Fotmob_Match (league_derived = "Premier League")
# Writes: results_cache_comp9.csv
#
# Output columns:
# season, match_id, match_date, home_team, away_team, home_goals, away_goals
# ------------------------------------------------------------
suppressPackageStartupMessages({
library(DBI)
library(RSQLite)
library(dplyr)
library(readr)
library(lubridate)
})
# ----------------------------
# Config
# ----------------------------
DB_PATH   <- Sys.getenv("FOOTBALLDB1_SQLITE", unset = "~/Data/footballdb1.sqlite")
SITE_ROOT <- "~/Projects/league-table-tool"
APP_DIR   <- file.path(SITE_ROOT, "shiny")
dir.create(APP_DIR, recursive = TRUE, showWarnings = FALSE)
OUT_CSV   <- file.path(APP_DIR, "results_cache_comp9.csv")
COMP_ID   <- 9
FOTMOB_LEAGUE <- "Premier League"
FOTMOB_MIN_SEASON_ENDYEAR <- 2026  # 2025/2026 season and later
# ----------------------------
# Helpers
# ----------------------------
clean_team_name <- function(x) {
x <- gsub("^(AFC|FC)\\s+", "", x, perl = TRUE)
x <- gsub("\\s+(AFC|FC)$", "", x, perl = TRUE)
trimws(x)
}
season_end_year <- function(season) {
# handles both "1990-1991" and "2025/2026"
y <- suppressWarnings(as.integer(substr(season, 6, 9)))
y
}
# ----------------------------
# Build cache
# ----------------------------
con <- dbConnect(RSQLite::SQLite(), path.expand(DB_PATH))
on.exit(dbDisconnect(con), add = TRUE)
# ---- Historical (up to 2024/2025, and anything pre-2025/2026) from Match/Team_Match/Team
sql_hist <- '
SELECT
m.season,
m.match_id,
m.match_date,
th.team_name AS home_team,
ta.team_name AS away_team,
tmh.goals     AS home_goals,
tma.goals     AS away_goals
FROM "Match" m
JOIN "Team" th
ON th.team_id = m.home_team_id
JOIN "Team" ta
ON ta.team_id = m.away_team_id
JOIN "Team_Match" tmh
ON tmh.match_id = m.match_id AND tmh.team_id = m.home_team_id
JOIN "Team_Match" tma
ON tma.match_id = m.match_id AND tma.team_id = m.away_team_id
WHERE m.competition_id = ?
ORDER BY m.match_date, m.match_id
'
hist <- dbGetQuery(con, sql_hist, params = list(COMP_ID)) |>
mutate(
match_date = as.Date(match_date),
home_goals = as.integer(home_goals),
away_goals = as.integer(away_goals),
home_team  = clean_team_name(home_team),
away_team  = clean_team_name(away_team),
season_end = season_end_year(season)
) |>
filter(!is.na(season_end), season_end < FOTMOB_MIN_SEASON_ENDYEAR) |>
select(season, match_id, match_date, home_team, away_team, home_goals, away_goals)
# ---- 2025/2026+ from Fotmob_Match
# match_time_utc example: 2025-08-31T15:30:00:000Z
# We'll parse to Date in R after pulling as text.
sql_fotmob <- '
SELECT
fm.season_derived AS season,
fm.match_id       AS match_id,
fm.match_time_utc AS match_time_utc,
fm.home_team_name AS home_team,
fm.away_team_name AS away_team,
fm.home_score     AS home_goals,
fm.away_score     AS away_goals
FROM "Fotmob_Match" fm
WHERE fm.league_derived = ?
ORDER BY fm.match_time_utc, fm.match_id
'
fotmob_raw <- dbGetQuery(con, sql_fotmob, params = list(FOTMOB_LEAGUE)) |>
mutate(
season = as.character(season),
season_end = season_end_year(season)
) |>
filter(!is.na(season_end), season_end >= FOTMOB_MIN_SEASON_ENDYEAR)
# Parse match_time_utc -> match_date
# Handle both "...:000Z" and standard ISO "...Z"
fotmob <- fotmob_raw |>
mutate(
match_date = suppressWarnings(as.Date(ymd_hms(match_time_utc, tz = "UTC"))),
match_date = ifelse(
is.na(match_date),
as.Date(parse_date_time(match_time_utc, orders = c("Ymd HMS", "Ymd HMS:OS", "YmdTHMS", "YmdTHMS:OS"), tz = "UTC")),
match_date
),
match_date = as.Date(match_date, origin = "1970-01-01"),
home_goals = as.integer(home_goals),
away_goals = as.integer(away_goals),
home_team  = clean_team_name(home_team),
away_team  = clean_team_name(away_team)
) |>
# Keep only matches with a parsable date; scores can be NA for future fixtures (that's fine)
filter(!is.na(match_date)) |>
select(season, match_id, match_date, home_team, away_team, home_goals, away_goals)
# ---- Combine and write
df <- bind_rows(hist, fotmob) |>
arrange(match_date, match_id)
if (nrow(df) == 0) stop("Combined query returned 0 rows. Check DB_PATH/schema/filters.")
write_csv(df, OUT_CSV)
message("Wrote ", nrow(df), " rows to ", OUT_CSV)
message(" - Historical rows: ", nrow(hist))
message(" - Fotmob rows:     ", nrow(fotmob))
runApp('~/Projects/league-table-tool/shiny')
28.26-24.58
26.9-31.1
### This script gets closing odds and player stats from the current
### tournament, and calculates forecast odds for winner after R3
# I may just have to manually enter the closing odds for now, since
# it appears DG don't add them until after the event.
# Set WD to avoid error at work
# setwd("C:/Users/knghj00/Documents/Golf/Multinomial R4 Model")
# Load required libraries
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
options(scipen=999) # stop scientific notation
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=1&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r1 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=2&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r2 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=3&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r3 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=event_avg&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
leaderboard <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
# Calculate stats as mean/sum of r1, r2, r3
cols_to_update <- c('accuracy', 'distance', 'gir', 'sg_app', 'sg_arg', 'sg_ott', 'sg_putt')
for (col in cols_to_update) {
leaderboard[[col]] <- rowMeans(cbind(r1[[col]], r2[[col]], r3[[col]]))
}
leaderboard[['total']] <- rowSums(cbind(r1[['round']], r2[['round']], r3[['round']]))
# Complete cases only
leaderboard <- leaderboard[complete.cases(leaderboard[,c('sg_app', 'sg_arg', 'sg_ott', 'sg_putt',
'total')]), ]
# Calculate features
leaderboard$strokes_back <- leaderboard$total - min(leaderboard$total)
leaderboard$is_leader <- ifelse(leaderboard$strokes_back==0, 1, 0)
leaderboard$strokes_ahead <- ifelse(leaderboard$strokes_back == 0, sort(leaderboard$total)[2] - leaderboard$total, 0)
leaderboard$one_back <- ifelse(leaderboard$strokes_back==1, 1, 0)
leaderboard$two_back <- ifelse(leaderboard$strokes_back==2, 1, 0)
# Calculate Kelly stakes with market regression
kelly <- function(my_odds, market_odds, bankroll, commission=0.02, regress=0.5) {
true_p <- 1 / (regress * market_odds + (1 - regress) * my_odds)
net_odds <- (market_odds - 1) * (1 - commission)
stake <- (true_p - (1 - true_p) / net_odds) * bankroll
stake <- round(stake, 2)
return(stake)
}
# Get the closing odds
manual_odds <- read.csv("~\\Sport\\Golf\\Datagolf\\Multinomial R4 Model\\Odds\\Hero World Challenge 2025.csv")
### This script gets closing odds and player stats from the current
### tournament, and calculates forecast odds for winner after R3
# I may just have to manually enter the closing odds for now, since
# it appears DG don't add them until after the event.
# Set WD to avoid error at work
# setwd("C:/Users/knghj00/Documents/Golf/Multinomial R4 Model")
# Load required libraries
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
options(scipen=999) # stop scientific notation
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=1&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r1 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=2&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r2 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=3&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r3 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=event_avg&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
leaderboard <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
# Calculate stats as mean/sum of r1, r2, r3
cols_to_update <- c('accuracy', 'distance', 'gir', 'sg_app', 'sg_arg', 'sg_ott', 'sg_putt')
for (col in cols_to_update) {
leaderboard[[col]] <- rowMeans(cbind(r1[[col]], r2[[col]], r3[[col]]))
}
leaderboard[['total']] <- rowSums(cbind(r1[['round']], r2[['round']], r3[['round']]))
# Complete cases only
leaderboard <- leaderboard[complete.cases(leaderboard[,c('sg_app', 'sg_arg', 'sg_ott', 'sg_putt',
'total')]), ]
# Calculate features
leaderboard$strokes_back <- leaderboard$total - min(leaderboard$total)
leaderboard$is_leader <- ifelse(leaderboard$strokes_back==0, 1, 0)
leaderboard$strokes_ahead <- ifelse(leaderboard$strokes_back == 0, sort(leaderboard$total)[2] - leaderboard$total, 0)
leaderboard$one_back <- ifelse(leaderboard$strokes_back==1, 1, 0)
leaderboard$two_back <- ifelse(leaderboard$strokes_back==2, 1, 0)
# Calculate Kelly stakes with market regression
kelly <- function(my_odds, market_odds, bankroll, commission=0.02, regress=0.5) {
true_p <- 1 / (regress * market_odds + (1 - regress) * my_odds)
net_odds <- (market_odds - 1) * (1 - commission)
stake <- (true_p - (1 - true_p) / net_odds) * bankroll
stake <- round(stake, 2)
return(stake)
}
# Get the closing odds
manual_odds <- read.csv("~\\Sport\\Golf\\Datagolf\\Multinomial R4 Model\\Odds\\Sony Open in Hawaii 2026.csv")
### This script gets closing odds and player stats from the current
### tournament, and calculates forecast odds for winner after R3
# I may just have to manually enter the closing odds for now, since
# it appears DG don't add them until after the event.
# Set WD to avoid error at work
# setwd("C:/Users/knghj00/Documents/Golf/Multinomial R4 Model")
# Load required libraries
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
options(scipen=999) # stop scientific notation
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=1&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r1 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=2&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r2 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=3&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r3 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=event_avg&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
leaderboard <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
# Calculate stats as mean/sum of r1, r2, r3
cols_to_update <- c('accuracy', 'distance', 'gir', 'sg_app', 'sg_arg', 'sg_ott', 'sg_putt')
for (col in cols_to_update) {
leaderboard[[col]] <- rowMeans(cbind(r1[[col]], r2[[col]], r3[[col]]))
}
leaderboard[['total']] <- rowSums(cbind(r1[['round']], r2[['round']], r3[['round']]))
# Complete cases only
leaderboard <- leaderboard[complete.cases(leaderboard[,c('sg_app', 'sg_arg', 'sg_ott', 'sg_putt',
'total')]), ]
# Calculate features
leaderboard$strokes_back <- leaderboard$total - min(leaderboard$total)
leaderboard$is_leader <- ifelse(leaderboard$strokes_back==0, 1, 0)
leaderboard$strokes_ahead <- ifelse(leaderboard$strokes_back == 0, sort(leaderboard$total)[2] - leaderboard$total, 0)
leaderboard$one_back <- ifelse(leaderboard$strokes_back==1, 1, 0)
leaderboard$two_back <- ifelse(leaderboard$strokes_back==2, 1, 0)
# Calculate Kelly stakes with market regression
kelly <- function(my_odds, market_odds, bankroll, commission=0.02, regress=0.5) {
true_p <- 1 / (regress * market_odds + (1 - regress) * my_odds)
net_odds <- (market_odds - 1) * (1 - commission)
stake <- (true_p - (1 - true_p) / net_odds) * bankroll
stake <- round(stake, 2)
return(stake)
}
# Get the closing odds
manual_odds <- read.csv("~/Sport/Golf/Datagolf/Multinomial R4 Model/Odds/Sony Open in Hawaii 2026.csv")
leaderboard <- merge(leaderboard, manual_odds[,c("player_names", "close_odds")], by.x="player_name", by.y="player_names", all.x=TRUE, all.y=FALSE)
leaderboard$close_odds[is.na(leaderboard$close_odds)] <- 100
coefficients <- c(-1.519, -1.077, -0.06, -0.906, -0.271, 0.046, 2.185,
4.418, -1.902, -1.494, -1.283, -1.487, -0.56)
leaderboard$log_close_odds <- log(leaderboard$close_odds)
selected_columns <- leaderboard[, c("strokes_back",
"is_leader",
"strokes_ahead",
"one_back",
"two_back",
"distance",
"accuracy",
"gir",
"sg_ott",
"sg_app",
"sg_arg",
"sg_putt",
"log_close_odds")]
# Initial value for my_intercept
my_intercept <- -3.4043
# Function to calculate the sum of probabilities given an intercept
calc_prob_sum <- function(intercept) {
logit <- as.vector(as.matrix(selected_columns) %*% coefficients + intercept)
exp_logit <- exp(logit)
prob <- exp_logit / (1 + exp_logit)
sum(prob)
}
# Function to be minimized by optim
objective_function <- function(intercept) {
(calc_prob_sum(intercept) - 1)^2
}
# Use optim to find the intercept that makes the sum of probabilities 1
result <- optim(par = my_intercept, fn = objective_function)
# The optimal intercept
optimal_intercept <- result$par
# Update the leaderboard with the optimal intercept
leaderboard$logit <- as.vector(as.matrix(selected_columns) %*% coefficients + optimal_intercept)
leaderboard$exp <- exp(leaderboard$logit)
leaderboard$prob <- leaderboard$exp / (1 + leaderboard$exp)
# Display the optimal intercept and the sum of probabilities
cat("Optimal intercept:", optimal_intercept, "\n")
cat("Sum of probabilities:", sum(leaderboard$prob), "\n")
leaderboard$odds <- round(1 / leaderboard$prob, 3)
leaderboard_trimmed <- leaderboard %>%
select(player_name, odds) %>%
mutate(odds = case_when(
odds < 2       ~ round(odds, 3),
odds < 5       ~ round(odds, 2),
odds < 50      ~ round(odds, 1),
TRUE           ~ round(odds, 0)
))
View(leaderboard_trimmed)
kelly(5.2, 6.6, 3807)
kelly(8.5, 13, 3807)
kelly(10.2, 12, 3807)
kelly(13.8, 20, 3807)
kelly(268, 360, 3807)
quarto render
quarto render
