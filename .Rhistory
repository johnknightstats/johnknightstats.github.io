prop = rep(1 / length(COUNTRY_ORDER), length(COUNTRY_ORDER))
)
legend_plot_src_pies <-
ggplot(legend_df_pies, aes(x = 1, y = prop, fill = country_name)) +
geom_col() +
coord_polar(theta = "y", start = PIE_START, direction = PIE_DIR) +
scale_fill_manual(values = COUNTRY_COLORS, breaks = COUNTRY_ORDER, limits = COUNTRY_ORDER, drop = FALSE) +
labs(fill = "Country") +
theme_void(base_size = 14) +
theme(
legend.position = "right",
legend.title = element_text(size = 14, face = "bold"),
legend.text  = element_text(size = 12),
legend.key.size = unit(0.9, "cm"),
legend.key = element_rect(fill = "grey92", color = "grey60")
)
legend_grob_pies <- extract_legend_grob(legend_plot_src_pies)
legend_panel_pies <- wrap_elements(full = legend_grob_pies)
final_plot_pies <-
(grid_plot | legend_panel_pies) +
plot_layout(widths = c(5, 1.5)) +
plot_annotation(
title = TITLE_TEXT,
theme = theme(
plot.title = element_text(
size = 18,
face = "bold",
hjust = 0.5,
margin = margin(b = 12)
)
)
)
# ----------------------------
# Timeline prep (FIXED: robust decade length + clamp xend to avoid clipping)
# ----------------------------
df_runs <- df %>%
arrange(decade, Date) %>%
group_by(decade) %>%
mutate(run_id = cumsum(country_name != lag(country_name, default = first(country_name)))) %>%
group_by(decade, run_id, country_name) %>%
summarise(start_date = min(Date), end_date = max(Date), .groups = "drop") %>%
mutate(
decade_num = as.numeric(factor(decade, levels = DECADES_KEEP)),
decade_start_year = as.integer(sub("s$", "", as.character(decade))),
decade_start = as.Date(paste0(decade_start_year, "-01-01")),
decade_end_excl = as.Date(paste0(decade_start_year + 10, "-01-01")),
decade_days = as.numeric(decade_end_excl - decade_start),
end_date_excl = end_date + days(1),
xstart_raw = as.numeric(start_date - decade_start) / decade_days,
xend_raw   = as.numeric(end_date_excl - decade_start) / decade_days,
xstart = pmin(pmax(xstart_raw, 0), 1),
xend   = pmin(pmax(xend_raw,   0), 1)
)
# ----------------------------
# Timeline plot core (NO title, NO legend; we add both via patchwork)
# ----------------------------
timeline_plot_core <-
ggplot(df_runs, aes(
xmin = xstart,
xmax = xend,
ymin = decade_num - 0.35,
ymax = decade_num + 0.35,
fill = country_name
)) +
geom_rect(color = "grey20", linewidth = 0.15) +
scale_fill_manual(values = COUNTRY_COLORS, limits = COUNTRY_ORDER, drop = FALSE) +
scale_y_reverse(
breaks = seq_along(DECADES_KEEP),
labels = DECADES_KEEP,
expand = expansion(add = 0.4)
) +
scale_x_continuous(
limits = c(0, 1),
breaks = seq(0, 0.9, by = 0.1),
labels = 0:9,
expand = c(0, 0)
) +
labs(
x = "Year",
y = NULL,
fill = "Country"
) +
theme_classic(base_size = 13) +
theme(
panel.grid = element_blank(),
axis.line = element_line(color = "black", linewidth = 0.6),
axis.text.y = element_text(face = "bold", size = 16),
axis.text.x = element_text(size = 14),
axis.title.x = element_text(size = 18),
legend.position = "none",
plot.margin = margin(t = 4, r = 8, b = 8, l = 8)
)
# ----------------------------
# Timeline legend (grob)
# ----------------------------
legend_df_tl <- tibble(
country_name = factor(COUNTRY_ORDER, levels = COUNTRY_ORDER),
dummy = 1
)
legend_plot_src_tl <-
ggplot(legend_df_tl, aes(x = dummy, fill = country_name)) +
geom_bar() +
scale_fill_manual(
values = COUNTRY_COLORS,
breaks = COUNTRY_ORDER,
limits = COUNTRY_ORDER,
drop = FALSE,
guide = guide_legend(
nrow = 2,
byrow = TRUE,
keywidth  = unit(0.6, "cm"),  # <-- increases column width
keyheight = unit(0.6, "cm")
)
) +
labs(fill = "Country") +
theme_void() +
theme(
legend.position = "top",
legend.direction = "horizontal",
legend.title = element_text(size = 20, face = "bold"),
legend.text  = element_text(
size = 20,
margin = margin(r = 12, l = 4)       # <-- adds extra gap after each label
),
# dark outline around the color squares (helps England)
legend.key = element_rect(
fill = NA,
color = "grey30",
linewidth = 0.4
),
legend.box.spacing = unit(0, "pt"),
legend.margin = margin(0, 0, 0, 0)
)
legend_grob_tl <- extract_legend_grob(legend_plot_src_tl)
legend_panel_tl <- wrap_elements(full = legend_grob_tl)
# ----------------------------
# Timeline: Title above, then legend, then plot (no overlap)
# ----------------------------
timeline_plot_final <-
(legend_panel_tl / timeline_plot_core) +
plot_layout(heights = c(1.2, 10)) +
plot_annotation(
title = TITLE_TEXT,
theme = theme(
plot.title = element_text(
size = 26,
face = "bold",
hjust = 0.5,
margin = margin(b = 8)
),
plot.margin = margin(t = 8, r = 8, b = 8, l = 8)
)
)
# ----------------------------
# Save
# ----------------------------
ggsave(
filename = OUT_PNG_PIES,
plot = final_plot_pies,
width = PNG_WIDTH_IN,
height = PNG_HEIGHT_IN,
dpi = PNG_DPI,
bg = "white"
)
message("Saved: ", OUT_PNG_PIES)
ggsave(
filename = OUT_PNG_TIMELINE,
plot = timeline_plot_final,
width = TL_WIDTH_IN,
height = TL_HEIGHT_IN,
dpi = PNG_DPI,
bg = "white"
)
message("Saved: ", OUT_PNG_TIMELINE)
#!/usr/bin/env Rscript
# ------------------------------------------------------------
# clubelo_number_one_pies_by_decade.R
#
# Reads:  posts/elo-number-one/data/processed/clubelo_number_one_daily.csv
# Writes: posts/elo-number-one/outputs/clubelo_number_one_pies_by_decade.png
#         posts/elo-number-one/outputs/clubelo_number_one_timeline_by_decade.png
#
# CSV columns: Date, Team, Country (Country is 3-letter code)
# ------------------------------------------------------------
suppressPackageStartupMessages({
library(readr)
library(dplyr)
library(stringr)
library(lubridate)
library(ggplot2)
library(patchwork)
library(grid)
library(tibble)
})
# ----------------------------
# Config
# ----------------------------
IN_CSV  <- "posts/elo-number-one/data/processed/clubelo_number_one_daily.csv"
OUT_DIR <- "posts/elo-number-one/outputs"
OUT_PNG_PIES     <- file.path(OUT_DIR, "clubelo_number_one_pies_by_decade.png")
OUT_PNG_TIMELINE <- file.path(OUT_DIR, "clubelo_number_one_timeline_by_decade.png")
DECADES_KEEP <- c("1940s","1950s","1960s","1970s","1980s","1990s","2000s","2010s","2020s")
COUNTRY_CODE_TO_NAME <- c(
"AUT" = "Austria",
"BEL" = "Belgium",
"ENG" = "England",
"ESP" = "Spain",
"GER" = "Germany",
"FRG" = "Germany",
"HUN" = "Hungary",
"ITA" = "Italy",
"NED" = "Netherlands",
"POR" = "Portugal",
"SCO" = "Scotland",
"SWE" = "Sweden"
)
COUNTRY_COLORS <- c(
"Austria"      = "#ED2939",
"Belgium"      = "pink",
"England"      = "white",
"Spain"        = "#8B0D11",
"Germany"      = "black",
"Hungary"      = "#477050",
"Italy"        = "royalblue",
"Netherlands"  = "#F46C22",
"Portugal"     = "turquoise",
"Scotland"     = "darkblue",
"Sweden"       = "yellow"
)
COUNTRY_ORDER <- names(COUNTRY_COLORS)
# Output size (3x3 pies + legend column)
PNG_WIDTH_IN  <- 16
PNG_HEIGHT_IN <- 12
PNG_DPI       <- 300
TITLE_TEXT <- "Nationality of Club Elo Number One Team by Decade"
# Pie orientation: 12 o'clock start, clockwise
PIE_START <- 0
PIE_DIR   <- 1
# Timeline output size
TL_WIDTH_IN  <- 16
TL_HEIGHT_IN <- 8
# ----------------------------
# Helpers
# ----------------------------
extract_legend_grob <- function(p) {
g <- ggplotGrob(p)
idx <- which(vapply(g$grobs, function(x) x$name, character(1)) == "guide-box")
if (length(idx) == 0) stop("No legend found.")
g$grobs[[idx[1]]]
}
# ----------------------------
# IO checks
# ----------------------------
if (!file.exists(IN_CSV)) stop("Input file not found: ", IN_CSV)
dir.create(OUT_DIR, showWarnings = FALSE, recursive = TRUE)
# ----------------------------
# Load + prep
# ----------------------------
df <- read_csv(IN_CSV, show_col_types = FALSE) %>%
mutate(
Date = as.Date(Date),
year = year(Date),
decade = paste0(floor(year / 10) * 10, "s"),
country_name = unname(COUNTRY_CODE_TO_NAME[str_squish(Country)])
) %>%
filter(decade %in% DECADES_KEEP, !is.na(country_name)) %>%
mutate(decade = factor(decade, levels = DECADES_KEEP))
# ----------------------------
# Pies: compute slice boundaries explicitly (largest starts at 12 o'clock)
# ----------------------------
df_dec <- df %>%
count(decade, country_name, name = "days") %>%
group_by(decade) %>%
mutate(prop = days / sum(days)) %>%
arrange(desc(prop), country_name) %>%
mutate(
ymax = cumsum(prop),
ymin = dplyr::lag(ymax, default = 0)
) %>%
ungroup()
pie_for_decade <- function(dec_label) {
d <- df_dec %>% filter(decade == dec_label)
ggplot(d, aes(
xmin = 0, xmax = 1,
ymin = ymin, ymax = ymax,
fill = country_name
)) +
geom_rect(color = "grey20", linewidth = 0.3) +
coord_polar(theta = "y", start = PIE_START, direction = PIE_DIR) +
scale_fill_manual(
values = COUNTRY_COLORS,
breaks = COUNTRY_ORDER,
limits = COUNTRY_ORDER,
drop = FALSE,
na.value = "grey80"
) +
labs(title = as.character(dec_label)) +
theme_void(base_size = 12) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
legend.position = "none"
)
}
plots <- lapply(levels(df$decade), pie_for_decade)
grid_plot <- wrap_plots(plots, ncol = 3)
# ----------------------------
# Build ONE legend (pies)
# ----------------------------
legend_df_pies <- tibble(
country_name = factor(COUNTRY_ORDER, levels = COUNTRY_ORDER),
prop = rep(1 / length(COUNTRY_ORDER), length(COUNTRY_ORDER))
)
legend_plot_src_pies <-
ggplot(legend_df_pies, aes(x = 1, y = prop, fill = country_name)) +
geom_col() +
coord_polar(theta = "y", start = PIE_START, direction = PIE_DIR) +
scale_fill_manual(values = COUNTRY_COLORS, breaks = COUNTRY_ORDER, limits = COUNTRY_ORDER, drop = FALSE) +
labs(fill = "Country") +
theme_void(base_size = 14) +
theme(
legend.position = "right",
legend.title = element_text(size = 14, face = "bold"),
legend.text  = element_text(size = 12),
legend.key.size = unit(0.9, "cm"),
legend.key = element_rect(fill = "grey92", color = "grey60")
)
legend_grob_pies <- extract_legend_grob(legend_plot_src_pies)
legend_panel_pies <- wrap_elements(full = legend_grob_pies)
final_plot_pies <-
(grid_plot | legend_panel_pies) +
plot_layout(widths = c(5, 1.5)) +
plot_annotation(
title = TITLE_TEXT,
theme = theme(
plot.title = element_text(
size = 18,
face = "bold",
hjust = 0.5,
margin = margin(b = 12)
)
)
)
# ----------------------------
# Timeline prep (FIXED: robust decade length + clamp xend to avoid clipping)
# ----------------------------
df_runs <- df %>%
arrange(decade, Date) %>%
group_by(decade) %>%
mutate(run_id = cumsum(country_name != lag(country_name, default = first(country_name)))) %>%
group_by(decade, run_id, country_name) %>%
summarise(start_date = min(Date), end_date = max(Date), .groups = "drop") %>%
mutate(
decade_num = as.numeric(factor(decade, levels = DECADES_KEEP)),
decade_start_year = as.integer(sub("s$", "", as.character(decade))),
decade_start = as.Date(paste0(decade_start_year, "-01-01")),
decade_end_excl = as.Date(paste0(decade_start_year + 10, "-01-01")),
decade_days = as.numeric(decade_end_excl - decade_start),
end_date_excl = end_date + days(1),
xstart_raw = as.numeric(start_date - decade_start) / decade_days,
xend_raw   = as.numeric(end_date_excl - decade_start) / decade_days,
xstart = pmin(pmax(xstart_raw, 0), 1),
xend   = pmin(pmax(xend_raw,   0), 1)
)
# ----------------------------
# Timeline plot core (NO title, NO legend; we add both via patchwork)
# ----------------------------
timeline_plot_core <-
ggplot(df_runs, aes(
xmin = xstart,
xmax = xend,
ymin = decade_num - 0.35,
ymax = decade_num + 0.35,
fill = country_name
)) +
geom_rect(color = "grey20", linewidth = 0.15) +
scale_fill_manual(values = COUNTRY_COLORS, limits = COUNTRY_ORDER, drop = FALSE) +
scale_y_reverse(
breaks = seq_along(DECADES_KEEP),
labels = DECADES_KEEP,
expand = expansion(add = 0.4)
) +
scale_x_continuous(
limits = c(0, 1),
breaks = seq(0, 0.9, by = 0.1),
labels = 0:9,
expand = c(0, 0)
) +
labs(
x = "Year",
y = NULL,
fill = "Country"
) +
theme_classic(base_size = 13) +
theme(
panel.grid = element_blank(),
axis.line = element_line(color = "black", linewidth = 0.6),
axis.text.y = element_text(face = "bold", size = 16),
axis.text.x = element_text(size = 14),
axis.title.x = element_text(size = 18),
legend.position = "none",
plot.margin = margin(t = 4, r = 8, b = 8, l = 8)
)
# ----------------------------
# Timeline legend (grob)
# ----------------------------
legend_df_tl <- tibble(
country_name = factor(COUNTRY_ORDER, levels = COUNTRY_ORDER),
dummy = 1
)
legend_plot_src_tl <-
ggplot(legend_df_tl, aes(x = dummy, fill = country_name)) +
geom_bar() +
scale_fill_manual(
values = COUNTRY_COLORS,
breaks = COUNTRY_ORDER,
limits = COUNTRY_ORDER,
drop = FALSE,
guide = guide_legend(
nrow = 2,
byrow = TRUE,
keywidth  = unit(0.6, "cm"),  # <-- increases column width
keyheight = unit(0.6, "cm")
)
) +
labs(fill = "Country") +
theme_void() +
theme(
legend.position = "top",
legend.direction = "horizontal",
legend.title = element_text(size = 20, face = "bold"),
legend.text  = element_text(
size = 20,
margin = margin(r = 12, l = 4)       # <-- adds extra gap after each label
),
# dark outline around the color squares (helps England)
legend.key = element_rect(
fill = NA,
color = "grey30",
linewidth = 0.4
),
legend.box.spacing = unit(0, "pt"),
legend.margin = margin(0, 0, 0, 0)
)
legend_grob_tl <- extract_legend_grob(legend_plot_src_tl)
legend_panel_tl <- wrap_elements(full = legend_grob_tl)
# ----------------------------
# Timeline: Title above, then legend, then plot (no overlap)
# ----------------------------
timeline_plot_final <-
(legend_panel_tl / timeline_plot_core) +
plot_layout(heights = c(1.2, 10)) +
plot_annotation(
title = TITLE_TEXT,
theme = theme(
plot.title = element_text(
size = 32,
face = "bold",
hjust = 0.5,
margin = margin(b = 8)
),
plot.margin = margin(t = 8, r = 8, b = 8, l = 8)
)
)
# ----------------------------
# Save
# ----------------------------
ggsave(
filename = OUT_PNG_PIES,
plot = final_plot_pies,
width = PNG_WIDTH_IN,
height = PNG_HEIGHT_IN,
dpi = PNG_DPI,
bg = "white"
)
message("Saved: ", OUT_PNG_PIES)
ggsave(
filename = OUT_PNG_TIMELINE,
plot = timeline_plot_final,
width = TL_WIDTH_IN,
height = TL_HEIGHT_IN,
dpi = PNG_DPI,
bg = "white"
)
message("Saved: ", OUT_PNG_TIMELINE)
document.getElementById("panel-premier-league").style.display = "none";
########################
### Elo Scores Model ###
########################
# Use a bivariate nested conditional Negative Binomial model to generate home
# and away goals based on difference in Elo ratings.
# From data inspection (see elo_calibration.R), it seems that favorites' goals
# when generated independently follow a negative binomial distribution with
# dispersion parameter ~ 35.
# However, underdog scores when viewed conditional on the favourite's score
# exhibit a higher dispersion with inflation of the 'draw' scores.
# Therefore, I will employ the following algorithm to calculate the probability
# distribution for the home and away score for each game:
# 1. Calculate the expected goals for the favourite from net elo diff using
# a simple quadratic model from Net Elo Diff (Elo Diff plus Home Advantage).
# 2. Get distribution for fav from expected goals using NB distribution.
# 3. Calculate expected goals for the underdog using a model that accounts for
# fav goals as well as Net Elo Diff.
# 4. Get distribution for the underdog using NB with an additional adjustment
# for the 'draw' scoreline and a counteradjustment to ensure expected goals remains the same.
# ---- Import libraries ----
library(tidyverse)
library(here)
library(rlang)
# Set a custom color palette
my_palette <- c("#233D4D", "#FF9F1C", "#41EAD4", "#FDFFFC", "#F71735")
# ---- Load utility functions ----
source(here("utils", "elo_helper_functions.R"))
