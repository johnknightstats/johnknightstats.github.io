dummy = 1
)
legend_plot_src_tl <-
ggplot(legend_df_tl, aes(x = dummy, fill = country_name)) +
geom_bar() +
scale_fill_manual(
values = COUNTRY_COLORS,
breaks = COUNTRY_ORDER,
limits = COUNTRY_ORDER,
drop = FALSE,
guide = guide_legend(
nrow = 2,
byrow = TRUE,
keywidth  = unit(0.6, "cm"),  # <-- increases column width
keyheight = unit(0.6, "cm")
)
) +
labs(fill = "Country") +
theme_void() +
theme(
legend.position = "top",
legend.direction = "horizontal",
legend.title = element_text(size = 20, face = "bold"),
legend.text  = element_text(
size = 20,
margin = margin(r = 12, l = 4)       # <-- adds extra gap after each label
),
# dark outline around the color squares (helps England)
legend.key = element_rect(
fill = NA,
color = "grey30",
linewidth = 0.4
),
legend.box.spacing = unit(0, "pt"),
legend.margin = margin(0, 0, 0, 0)
)
legend_grob_tl <- extract_legend_grob(legend_plot_src_tl)
legend_panel_tl <- wrap_elements(full = legend_grob_tl)
# ----------------------------
# Timeline: Title above, then legend, then plot (no overlap)
# ----------------------------
timeline_plot_final <-
(legend_panel_tl / timeline_plot_core) +
plot_layout(heights = c(1.2, 10)) +
plot_annotation(
title = TITLE_TEXT,
theme = theme(
plot.title = element_text(
size = 32,
face = "bold",
hjust = 0.5,
margin = margin(b = 8)
),
plot.margin = margin(t = 8, r = 8, b = 8, l = 8)
)
)
# ----------------------------
# Save
# ----------------------------
ggsave(
filename = OUT_PNG_PIES,
plot = final_plot_pies,
width = PNG_WIDTH_IN,
height = PNG_HEIGHT_IN,
dpi = PNG_DPI,
bg = "white"
)
message("Saved: ", OUT_PNG_PIES)
ggsave(
filename = OUT_PNG_TIMELINE,
plot = timeline_plot_final,
width = TL_WIDTH_IN,
height = TL_HEIGHT_IN,
dpi = PNG_DPI,
bg = "white"
)
message("Saved: ", OUT_PNG_TIMELINE)
document.getElementById("panel-premier-league").style.display = "none";
########################
### Elo Scores Model ###
########################
# Use a bivariate nested conditional Negative Binomial model to generate home
# and away goals based on difference in Elo ratings.
# From data inspection (see elo_calibration.R), it seems that favorites' goals
# when generated independently follow a negative binomial distribution with
# dispersion parameter ~ 35.
# However, underdog scores when viewed conditional on the favourite's score
# exhibit a higher dispersion with inflation of the 'draw' scores.
# Therefore, I will employ the following algorithm to calculate the probability
# distribution for the home and away score for each game:
# 1. Calculate the expected goals for the favourite from net elo diff using
# a simple quadratic model from Net Elo Diff (Elo Diff plus Home Advantage).
# 2. Get distribution for fav from expected goals using NB distribution.
# 3. Calculate expected goals for the underdog using a model that accounts for
# fav goals as well as Net Elo Diff.
# 4. Get distribution for the underdog using NB with an additional adjustment
# for the 'draw' scoreline and a counteradjustment to ensure expected goals remains the same.
# ---- Import libraries ----
library(tidyverse)
library(here)
library(rlang)
# Set a custom color palette
my_palette <- c("#233D4D", "#FF9F1C", "#41EAD4", "#FDFFFC", "#F71735")
# ---- Load utility functions ----
source(here("utils", "elo_helper_functions.R"))
### This script gets closing odds and player stats from the current
### tournament, and calculates forecast odds for winner after R3
# I may just have to manually enter the closing odds for now, since
# it appears DG don't add them until after the event.
# Set WD to avoid error at work
# setwd("C:/Users/knghj00/Documents/Golf/Multinomial R4 Model")
# Load required libraries
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
options(scipen=999) # stop scientific notation
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=1&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r1 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=2&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r2 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=3&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r3 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=event_avg&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
leaderboard <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
# Calculate stats as mean/sum of r1, r2, r3
cols_to_update <- c('accuracy', 'distance', 'gir', 'sg_app', 'sg_arg', 'sg_ott', 'sg_putt')
for (col in cols_to_update) {
leaderboard[[col]] <- rowMeans(cbind(r1[[col]], r2[[col]], r3[[col]]))
}
leaderboard[['total']] <- rowSums(cbind(r1[['round']], r2[['round']], r3[['round']]))
# Complete cases only
leaderboard <- leaderboard[complete.cases(leaderboard[,c('sg_app', 'sg_arg', 'sg_ott', 'sg_putt',
'total')]), ]
# Calculate features
leaderboard$strokes_back <- leaderboard$total - min(leaderboard$total)
leaderboard$is_leader <- ifelse(leaderboard$strokes_back==0, 1, 0)
leaderboard$strokes_ahead <- ifelse(leaderboard$strokes_back == 0, sort(leaderboard$total)[2] - leaderboard$total, 0)
leaderboard$one_back <- ifelse(leaderboard$strokes_back==1, 1, 0)
leaderboard$two_back <- ifelse(leaderboard$strokes_back==2, 1, 0)
# Calculate Kelly stakes with market regression
kelly <- function(my_odds, market_odds, bankroll, commission=0.02, regress=0.5) {
true_p <- 1 / (regress * market_odds + (1 - regress) * my_odds)
net_odds <- (market_odds - 1) * (1 - commission)
stake <- (true_p - (1 - true_p) / net_odds) * bankroll
stake <- round(stake, 2)
return(stake)
}
# Get the closing odds
manual_odds <- read.csv("~/Sport/Golf/Datagolf/Multinomial R4 Model/Odds/WM Phoenix Open 2026.csv")
leaderboard <- merge(leaderboard, manual_odds[,c("player_names", "close_odds")], by.x="player_name", by.y="player_names", all.x=TRUE, all.y=FALSE)
leaderboard$close_odds[is.na(leaderboard$close_odds)] <- 100
coefficients <- c(-1.519, -1.077, -0.06, -0.906, -0.271, 0.046, 2.185,
4.418, -1.902, -1.494, -1.283, -1.487, -0.56)
leaderboard$log_close_odds <- log(leaderboard$close_odds)
selected_columns <- leaderboard[, c("strokes_back",
"is_leader",
"strokes_ahead",
"one_back",
"two_back",
"distance",
"accuracy",
"gir",
"sg_ott",
"sg_app",
"sg_arg",
"sg_putt",
"log_close_odds")]
# Initial value for my_intercept
my_intercept <- -3.4043
# Function to calculate the sum of probabilities given an intercept
calc_prob_sum <- function(intercept) {
logit <- as.vector(as.matrix(selected_columns) %*% coefficients + intercept)
exp_logit <- exp(logit)
prob <- exp_logit / (1 + exp_logit)
sum(prob)
}
# Function to be minimized by optim
objective_function <- function(intercept) {
(calc_prob_sum(intercept) - 1)^2
}
# Use optim to find the intercept that makes the sum of probabilities 1
result <- optim(par = my_intercept, fn = objective_function)
# The optimal intercept
optimal_intercept <- result$par
# Update the leaderboard with the optimal intercept
leaderboard$logit <- as.vector(as.matrix(selected_columns) %*% coefficients + optimal_intercept)
leaderboard$exp <- exp(leaderboard$logit)
leaderboard$prob <- leaderboard$exp / (1 + leaderboard$exp)
# Display the optimal intercept and the sum of probabilities
cat("Optimal intercept:", optimal_intercept, "\n")
cat("Sum of probabilities:", sum(leaderboard$prob), "\n")
leaderboard$odds <- round(1 / leaderboard$prob, 3)
leaderboard_trimmed <- leaderboard %>%
select(player_name, odds) %>%
mutate(odds = case_when(
odds < 2       ~ round(odds, 3),
odds < 5       ~ round(odds, 2),
odds < 50      ~ round(odds, 1),
TRUE           ~ round(odds, 0)
))
View(leaderboard_trimmed)
kelly(9.7, 17.5, 3573)
kelly(11.8, 16, 3573)
kelly(12.9, 16, 3573)
kelly(49.7, 100, 3573)
kelly(59, 100, 3573)
1727/2328
1727/2328*90
2591/3566*90
3248/3498*90
### Grabs the closing odds for current events (need to run on a Thursday before round ends) ###
library(httr)
library(jsonlite)
setwd("~/Sport/Golf/Datagolf/Multinomial R4 Model/Odds")
url <- 'https://feeds.datagolf.com/betting-tools/outrights?tour=pga&market=win&odds_format=decimal&file_format=json&key=6a38380b526586b5c052d3db3bce'
response <- GET(url)
if (http_status(response)$category == "Success") {
# Parse JSON content and return
api_data <- content(response, "text", encoding = "UTF-8")
} else {
# Return NULL or handle error as needed
warning(paste("Failed to retrieve data for tour:", tour, "event_id:", event_id, "year:", year))
}
json_data <- fromJSON(api_data)
event_name <- json_data[['event_name']]
last_updated <- json_data[['last_updated']]
player_names <- json_data[['odds']][['player_name']]
pinnacle <- json_data[['odds']][['pinnacle']]
draftkings <- json_data[['odds']][['draftkings']]
fanduel <- json_data[['odds']][['fanduel']]
williamhill <- json_data[['odds']][['williamhill']]
my_odds <- data.frame(player_names, pinnacle, draftkings, fanduel, williamhill)
my_odds$close_odds <- pmax(my_odds$pinnacle, my_odds$draftkings, my_odds$fanduel, my_odds$williamhill, na.rm=TRUE)
year <- substr(last_updated, 1, 4)
filename <- paste0(event_name, ' ', year, '.csv')
write.csv(my_odds, filename, row.names=FALSE)
View(my_odds)
0.001*45
exp(-0.001)
0.999^45
exp(1.813)
exp(1.75)
exp(0.1813)
exp(0.175)
0.026*0.999^45
0.021*0.999^45
### This script gets closing odds and player stats from the current
### tournament, and calculates forecast odds for winner after R3
# I may just have to manually enter the closing odds for now, since
# it appears DG don't add them until after the event.
# Set WD to avoid error at work
# setwd("C:/Users/knghj00/Documents/Golf/Multinomial R4 Model")
# Load required libraries
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
options(scipen=999) # stop scientific notation
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=1&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r1 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=2&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r2 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=3&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r3 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=event_avg&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
leaderboard <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
# Calculate stats as mean/sum of r1, r2, r3
cols_to_update <- c('accuracy', 'distance', 'gir', 'sg_app', 'sg_arg', 'sg_ott', 'sg_putt')
for (col in cols_to_update) {
leaderboard[[col]] <- rowMeans(cbind(r1[[col]], r2[[col]], r3[[col]]))
}
leaderboard[['total']] <- rowSums(cbind(r1[['round']], r2[['round']], r3[['round']]))
# Complete cases only
leaderboard <- leaderboard[complete.cases(leaderboard[,c('sg_app', 'sg_arg', 'sg_ott', 'sg_putt',
'total')]), ]
# Calculate features
leaderboard$strokes_back <- leaderboard$total - min(leaderboard$total)
leaderboard$is_leader <- ifelse(leaderboard$strokes_back==0, 1, 0)
leaderboard$strokes_ahead <- ifelse(leaderboard$strokes_back == 0, sort(leaderboard$total)[2] - leaderboard$total, 0)
leaderboard$one_back <- ifelse(leaderboard$strokes_back==1, 1, 0)
leaderboard$two_back <- ifelse(leaderboard$strokes_back==2, 1, 0)
# Calculate Kelly stakes with market regression
kelly <- function(my_odds, market_odds, bankroll, commission=0.02, regress=0.5) {
true_p <- 1 / (regress * market_odds + (1 - regress) * my_odds)
net_odds <- (market_odds - 1) * (1 - commission)
stake <- (true_p - (1 - true_p) / net_odds) * bankroll
stake <- round(stake, 2)
return(stake)
}
# Get the closing odds
manual_odds <- read.csv("~/Sport/Golf/Datagolf/Multinomial R4 Model/Odds/AT&T Pebble Beach Pro-Am 2026.csv")
leaderboard <- merge(leaderboard, manual_odds[,c("player_names", "close_odds")], by.x="player_name", by.y="player_names", all.x=TRUE, all.y=FALSE)
leaderboard$close_odds[is.na(leaderboard$close_odds)] <- 100
coefficients <- c(-1.519, -1.077, -0.06, -0.906, -0.271, 0.046, 2.185,
4.418, -1.902, -1.494, -1.283, -1.487, -0.56)
leaderboard$log_close_odds <- log(leaderboard$close_odds)
selected_columns <- leaderboard[, c("strokes_back",
"is_leader",
"strokes_ahead",
"one_back",
"two_back",
"distance",
"accuracy",
"gir",
"sg_ott",
"sg_app",
"sg_arg",
"sg_putt",
"log_close_odds")]
# Initial value for my_intercept
my_intercept <- -3.4043
# Function to calculate the sum of probabilities given an intercept
calc_prob_sum <- function(intercept) {
logit <- as.vector(as.matrix(selected_columns) %*% coefficients + intercept)
exp_logit <- exp(logit)
prob <- exp_logit / (1 + exp_logit)
sum(prob)
}
# Function to be minimized by optim
objective_function <- function(intercept) {
(calc_prob_sum(intercept) - 1)^2
}
# Use optim to find the intercept that makes the sum of probabilities 1
result <- optim(par = my_intercept, fn = objective_function)
# The optimal intercept
optimal_intercept <- result$par
# Update the leaderboard with the optimal intercept
leaderboard$logit <- as.vector(as.matrix(selected_columns) %*% coefficients + optimal_intercept)
leaderboard$exp <- exp(leaderboard$logit)
leaderboard$prob <- leaderboard$exp / (1 + leaderboard$exp)
# Display the optimal intercept and the sum of probabilities
cat("Optimal intercept:", optimal_intercept, "\n")
cat("Sum of probabilities:", sum(leaderboard$prob), "\n")
leaderboard$odds <- round(1 / leaderboard$prob, 3)
leaderboard_trimmed <- leaderboard %>%
select(player_name, odds) %>%
mutate(odds = case_when(
odds < 2       ~ round(odds, 3),
odds < 5       ~ round(odds, 2),
odds < 50      ~ round(odds, 1),
TRUE           ~ round(odds, 0)
))
View(leaderboard_trimmed)
kelly(2.21, 2.9, 3000)
### This script gets closing odds and player stats from the current
### tournament, and calculates forecast odds for winner after R3
# I may just have to manually enter the closing odds for now, since
# it appears DG don't add them until after the event.
# Set WD to avoid error at work
# setwd("C:/Users/knghj00/Documents/Golf/Multinomial R4 Model")
# Load required libraries
library(httr)
library(jsonlite)
library(readxl)
library(dplyr)
options(scipen=999) # stop scientific notation
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=1&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r1 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=2&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r2 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=3&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
r3 <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
url <- "https://feeds.datagolf.com/preds/live-tournament-stats?stats=sg_putt,sg_arg,sg_app,sg_ott,distance,accuracy,gir,&round=event_avg&tour=pga&key=6a38380b526586b5c052d3db3bce"
response <- GET(url)
leaderboard <- fromJSON(content(response, "text", encoding = "UTF-8"))[['live_stats']]
# Calculate stats as mean/sum of r1, r2, r3
cols_to_update <- c('accuracy', 'distance', 'gir', 'sg_app', 'sg_arg', 'sg_ott', 'sg_putt')
for (col in cols_to_update) {
leaderboard[[col]] <- rowMeans(cbind(r1[[col]], r2[[col]], r3[[col]]))
}
leaderboard[['total']] <- rowSums(cbind(r1[['round']], r2[['round']], r3[['round']]))
# Complete cases only
leaderboard <- leaderboard[complete.cases(leaderboard[,c('sg_app', 'sg_arg', 'sg_ott', 'sg_putt',
'total')]), ]
# Calculate features
leaderboard$strokes_back <- leaderboard$total - min(leaderboard$total)
leaderboard$is_leader <- ifelse(leaderboard$strokes_back==0, 1, 0)
leaderboard$strokes_ahead <- ifelse(leaderboard$strokes_back == 0, sort(leaderboard$total)[2] - leaderboard$total, 0)
leaderboard$one_back <- ifelse(leaderboard$strokes_back==1, 1, 0)
leaderboard$two_back <- ifelse(leaderboard$strokes_back==2, 1, 0)
# Calculate Kelly stakes with market regression
kelly <- function(my_odds, market_odds, bankroll, commission=0.02, regress=0.5) {
true_p <- 1 / (regress * market_odds + (1 - regress) * my_odds)
net_odds <- (market_odds - 1) * (1 - commission)
stake <- (true_p - (1 - true_p) / net_odds) * bankroll
stake <- round(stake, 2)
return(stake)
}
# Get the closing odds
manual_odds <- read.csv("~/Sport/Golf/Datagolf/Multinomial R4 Model/Odds/AT&T Pebble Beach Pro-Am 2026.csv")
leaderboard <- merge(leaderboard, manual_odds[,c("player_names", "close_odds")], by.x="player_name", by.y="player_names", all.x=TRUE, all.y=FALSE)
leaderboard$close_odds[is.na(leaderboard$close_odds)] <- 100
coefficients <- c(-1.519, -1.077, -0.06, -0.906, -0.271, 0.046, 2.185,
4.418, -1.902, -1.494, -1.283, -1.487, -0.56)
leaderboard$log_close_odds <- log(leaderboard$close_odds)
selected_columns <- leaderboard[, c("strokes_back",
"is_leader",
"strokes_ahead",
"one_back",
"two_back",
"distance",
"accuracy",
"gir",
"sg_ott",
"sg_app",
"sg_arg",
"sg_putt",
"log_close_odds")]
# Initial value for my_intercept
my_intercept <- -3.4043
# Function to calculate the sum of probabilities given an intercept
calc_prob_sum <- function(intercept) {
logit <- as.vector(as.matrix(selected_columns) %*% coefficients + intercept)
exp_logit <- exp(logit)
prob <- exp_logit / (1 + exp_logit)
sum(prob)
}
# Function to be minimized by optim
objective_function <- function(intercept) {
(calc_prob_sum(intercept) - 1)^2
}
# Use optim to find the intercept that makes the sum of probabilities 1
result <- optim(par = my_intercept, fn = objective_function)
# The optimal intercept
optimal_intercept <- result$par
# Update the leaderboard with the optimal intercept
leaderboard$logit <- as.vector(as.matrix(selected_columns) %*% coefficients + optimal_intercept)
leaderboard$exp <- exp(leaderboard$logit)
leaderboard$prob <- leaderboard$exp / (1 + leaderboard$exp)
# Display the optimal intercept and the sum of probabilities
cat("Optimal intercept:", optimal_intercept, "\n")
cat("Sum of probabilities:", sum(leaderboard$prob), "\n")
leaderboard$odds <- round(1 / leaderboard$prob, 3)
leaderboard_trimmed <- leaderboard %>%
select(player_name, odds) %>%
mutate(odds = case_when(
odds < 2       ~ round(odds, 3),
odds < 5       ~ round(odds, 2),
odds < 50      ~ round(odds, 1),
TRUE           ~ round(odds, 0)
))
View(leaderboard_trimmed)
kelly(2.21, 3.1, 3443)
kelly(17.8, 22, 3443)
1/1.42
ls
### Grabs the closing odds for current events (need to run on a Thursday before round ends) ###
library(httr)
library(jsonlite)
setwd("~/Sport/Golf/Datagolf/Multinomial R4 Model/Odds")
url <- 'https://feeds.datagolf.com/betting-tools/outrights?tour=pga&market=win&odds_format=decimal&file_format=json&key=6a38380b526586b5c052d3db3bce'
response <- GET(url)
if (http_status(response)$category == "Success") {
# Parse JSON content and return
api_data <- content(response, "text", encoding = "UTF-8")
} else {
# Return NULL or handle error as needed
warning(paste("Failed to retrieve data for tour:", tour, "event_id:", event_id, "year:", year))
}
json_data <- fromJSON(api_data)
event_name <- json_data[['event_name']]
last_updated <- json_data[['last_updated']]
player_names <- json_data[['odds']][['player_name']]
pinnacle <- json_data[['odds']][['pinnacle']]
draftkings <- json_data[['odds']][['draftkings']]
fanduel <- json_data[['odds']][['fanduel']]
williamhill <- json_data[['odds']][['williamhill']]
my_odds <- data.frame(player_names, pinnacle, draftkings, fanduel, williamhill)
my_odds$close_odds <- pmax(my_odds$pinnacle, my_odds$draftkings, my_odds$fanduel, my_odds$williamhill, na.rm=TRUE)
year <- substr(last_updated, 1, 4)
filename <- paste0(event_name, ' ', year, '.csv')
write.csv(my_odds, filename, row.names=FALSE)
View(my_odds)
### Grabs the closing odds for current events (need to run on a Thursday before round ends) ###
library(httr)
library(jsonlite)
setwd("~/Sport/Golf/Datagolf/Multinomial R4 Model/Odds")
url <- 'https://feeds.datagolf.com/betting-tools/outrights?tour=pga&market=win&odds_format=decimal&file_format=json&key=6a38380b526586b5c052d3db3bce'
response <- GET(url)
if (http_status(response)$category == "Success") {
# Parse JSON content and return
api_data <- content(response, "text", encoding = "UTF-8")
} else {
# Return NULL or handle error as needed
warning(paste("Failed to retrieve data for tour:", tour, "event_id:", event_id, "year:", year))
}
json_data <- fromJSON(api_data)
event_name <- json_data[['event_name']]
last_updated <- json_data[['last_updated']]
player_names <- json_data[['odds']][['player_name']]
pinnacle <- json_data[['odds']][['pinnacle']]
draftkings <- json_data[['odds']][['draftkings']]
fanduel <- json_data[['odds']][['fanduel']]
williamhill <- json_data[['odds']][['williamhill']]
my_odds <- data.frame(player_names, pinnacle, draftkings, fanduel, williamhill)
my_odds$close_odds <- pmax(my_odds$pinnacle, my_odds$draftkings, my_odds$fanduel, my_odds$williamhill, na.rm=TRUE)
year <- substr(last_updated, 1, 4)
filename <- paste0(event_name, ' ', year, '.csv')
write.csv(my_odds, filename, row.names=FALSE)
View(my_odds)
